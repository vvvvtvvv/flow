"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[5131],{15131:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>c,default:()=>p,frontMatter:()=>r,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"types/const-expression","title":"Const Expressions","description":"Sometimes it is useful to specify that a literal expression is expected to be immutable.","source":"@site/docs/types/const-expression.md","sourceDirName":"types","slug":"/types/const-expression","permalink":"/en/docs/types/const-expression","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/types/const-expression.md","tags":[],"version":"current","frontMatter":{"title":"Const Expressions","slug":"/types/const-expression"},"sidebar":"docsSidebar","previous":{"title":"Type Casting Expressions","permalink":"/en/docs/types/casting"},"next":{"title":"Utility Types","permalink":"/en/docs/types/utilities"}}');var o=n(74848),i=n(28453);const r={title:"Const Expressions",slug:"/types/const-expression"},c=void 0,l={},a=[{value:"Typing for Const Expressions",id:"toc-const-expression-typing",level:2},{value:"Typical const-expression example",id:"toc-const-expression-example",level:2},{value:"Adoption of <code>as const</code> syntax",id:"adoption-of-as-const-syntax",level:2},{value:"<code>const</code> Type Parameters",id:"const-type-parameters",level:2},{value:"Adoption of <code>const</code> type parameter syntax",id:"adoption-of-const-type-parameter-syntax",level:2}];function d(e){const s={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(s.p,{children:["Sometimes it is useful to specify that a literal expression is expected to be immutable.\nIn such cases, you can annotate the expression with the ",(0,o.jsx)(s.code,{children:"as const"})," modifier. We\nrefer to these expressions as const-expressions."]}),"\n",(0,o.jsx)(s.h2,{id:"toc-const-expression-typing",children:"Typing for Const Expressions"}),"\n",(0,o.jsxs)(s.p,{children:["The inferred type of const-expressions is the ",(0,o.jsx)(s.a,{href:"../literals",children:"singleton type"})," for primitive values\nand the read-only versions for container types. Array literals are inferred as tuple types."]}),"\n",(0,o.jsx)(s.p,{children:"Here are some examples of primitive values:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-js",children:'42 as const; // inferred type is 42\n\n"hello" as const; // inferred type is "hello"\n'})}),"\n",(0,o.jsx)(s.p,{children:"Containers become read-only and the modifier is applied deeply"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-js",children:'{ f: 42 } as const; // {+f: 42}\n\n[42, "hello"] as const; // $ReadOnly<[42, "hello"]>\n\n{ f: { g: 42 } } as const; // {+f: {+g: 42}}\n'})}),"\n",(0,o.jsx)(s.p,{children:"Note that the effect of the modifier does not persist through variables. For example\nin"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-js",children:"const nonConstObject = { g: 42 };\nconst constObject = { f: nonConstObject } as const;\n"})}),"\n",(0,o.jsxs)(s.p,{children:["the type of ",(0,o.jsx)(s.code,{children:"nonConstObject"})," will be ",(0,o.jsx)(s.code,{children:"{g: number}"})," and the type of ",(0,o.jsx)(s.code,{children:"constObject"})," will\nbe ",(0,o.jsx)(s.code,{children:"{+f: {g: number}}"}),". In other words, only the top-level property ",(0,o.jsx)(s.code,{children:"prop"})," will\nbe read-only."]}),"\n",(0,o.jsxs)(s.p,{children:["Finally, it is an error to apply ",(0,o.jsx)(s.code,{children:"as const"})," to non-literal expressions:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-flow",metastring:"[]",children:"const x = 1;\nconst y = x as const;\n"})}),"\n",(0,o.jsx)(s.h2,{id:"toc-const-expression-example",children:"Typical const-expression example"}),"\n",(0,o.jsx)(s.p,{children:"A common pattern where const-expressions are useful is in enum-like\nstructures that are not expected to be mutated. For example"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-js",children:"export const STATUS = {\n  INIT: 'INIT',\n  LOADING: 'LOADING',\n  SUCCESS: 'SUCCESS',\n  ERROR: 'ERROR',\n} as const;\n"})}),"\n",(0,o.jsxs)(s.p,{children:["The type of ",(0,o.jsx)(s.code,{children:"STATUS.INIT"})," is ",(0,o.jsx)(s.code,{children:'"INIT"'}),", the type of ",(0,o.jsx)(s.code,{children:"STATUS.LOADING"})," is ",(0,o.jsx)(s.code,{children:'"LOADING"'})," and so on."]}),"\n",(0,o.jsx)(s.p,{children:"With this definition it is also possible to effectively lift the values of the various fields\nto type annotations. For example"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-js",children:"type State =\n  | { +kind: typeof STATUS.INIT; }\n  | { +kind: typeof STATUS.LOADING; progress: number; }\n  | { +kind: typeof STATUS.SUCCESS; result: string; }\n  | { +kind: typeof STATUS.ERROR; msg: string; };\n"})}),"\n",(0,o.jsxs)(s.p,{children:["Without the use of ",(0,o.jsx)(s.code,{children:"as const"})," the type ",(0,o.jsx)(s.code,{children:"typeof STATUS.INIT"})," would be ",(0,o.jsx)(s.code,{children:"string"}),", which\nwould make it unsuitable as a distinguishing tag in a disjoint union."]}),"\n",(0,o.jsxs)(s.h2,{id:"adoption-of-as-const-syntax",children:["Adoption of ",(0,o.jsx)(s.code,{children:"as const"})," syntax"]}),"\n",(0,o.jsxs)(s.p,{children:["To use the ",(0,o.jsx)(s.code,{children:"as const"})," syntax, you need to upgrade your infrastructure:"]}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:"Flow and Flow Parser: 0.256+"}),"\n",(0,o.jsx)(s.li,{children:"Prettier: 3.1+"}),"\n",(0,o.jsxs)(s.li,{children:["Babel: use the ",(0,o.jsx)(s.a,{href:"https://www.npmjs.com/package/babel-plugin-syntax-hermes-parser",children:"babel-plugin-syntax-hermes-parser"})," plugin version 0.19+, see our ",(0,o.jsx)(s.a,{href:"../../tools/babel",children:"Babel guide"})," for more details."]}),"\n",(0,o.jsxs)(s.li,{children:["ESLint: use ",(0,o.jsx)(s.a,{href:"https://www.npmjs.com/package/hermes-eslint",children:"hermes-eslint"})," plugin version 0.19+, see our ",(0,o.jsx)(s.a,{href:"../../tools/eslint",children:"ESLint guide"})," for more details."]}),"\n"]}),"\n",(0,o.jsxs)(s.h2,{id:"const-type-parameters",children:[(0,o.jsx)(s.code,{children:"const"})," Type Parameters"]}),"\n",(0,o.jsxs)(s.p,{children:["Sometimes it is useful to specify that an argument to a function is always expected\nto be a const-expression. In such cases, you can annotate the type parameter with\nthe ",(0,o.jsx)(s.code,{children:"const"})," modifier. We refer to these type parameters as const-type parameters."]}),"\n",(0,o.jsxs)(s.p,{children:["When are ",(0,o.jsx)(s.code,{children:"const"})," type parameters useful?"]}),"\n",(0,o.jsxs)(s.p,{children:["One example is when you want to enforce that all arguments passed to a function\n",(0,o.jsx)(s.code,{children:"foo"})," with signature"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{children:"declare function foo<X>(x: X): X;\n"})}),"\n",(0,o.jsxs)(s.p,{children:["need to be treated as const-expressions. One way to support this is by always\ncalling ",(0,o.jsx)(s.code,{children:"foo"})," with ",(0,o.jsx)(s.code,{children:"as const"})," on its argument:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-js",children:'const x1 = foo({ f: 42 } as const);\nconst x2 = foo([42, "hello"] as const);\n'})}),"\n",(0,o.jsxs)(s.p,{children:["The variables ",(0,o.jsx)(s.code,{children:"x1"})," and ",(0,o.jsx)(s.code,{children:"x2"})," will have the type ",(0,o.jsx)(s.code,{children:"{+f: 42}"})," and ",(0,o.jsx)(s.code,{children:'$ReadOnly<[42, "hello"]>'}),",\nrespectively."]}),"\n",(0,o.jsxs)(s.p,{children:["To avoid repeating and potentially forgetting to pass ",(0,o.jsx)(s.code,{children:"as const"}),", you can use the\n",(0,o.jsx)(s.code,{children:"const"})," modifier on type parameter ",(0,o.jsx)(s.code,{children:"X"}),":"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-js",children:"declare function constFoo<const X>(x: X): X;\n"})}),"\n",(0,o.jsxs)(s.p,{children:["Now you can call ",(0,o.jsx)(s.code,{children:"constFoo"})," without ",(0,o.jsx)(s.code,{children:"as const"})," and have the same effect as before:"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-js",children:'const y1 = constFoo({ f: 42 });\nconst y2 = constFoo([42, "hello"]);\n'})}),"\n",(0,o.jsxs)(s.p,{children:["The variables ",(0,o.jsx)(s.code,{children:"y1"})," and ",(0,o.jsx)(s.code,{children:"y2"})," will have the same type as ",(0,o.jsx)(s.code,{children:"x1"})," and ",(0,o.jsx)(s.code,{children:"x2"}),", respectively."]}),"\n",(0,o.jsxs)(s.h2,{id:"adoption-of-const-type-parameter-syntax",children:["Adoption of ",(0,o.jsx)(s.code,{children:"const"})," type parameter syntax"]}),"\n",(0,o.jsxs)(s.p,{children:["To use the ",(0,o.jsx)(s.code,{children:"as const"})," syntax, you need to upgrade your infrastructure:"]}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:["Flow and Flow Parser:","\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:["0.267 and 0.268 and passing the ",(0,o.jsx)(s.code,{children:"experimental.const_type_params=true"})," flag in the flowconfig"]}),"\n",(0,o.jsx)(s.li,{children:"0.269+ without the flag."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(s.li,{children:"Prettier: 3.5+"}),"\n",(0,o.jsxs)(s.li,{children:["Babel: use the ",(0,o.jsx)(s.a,{href:"https://www.npmjs.com/package/babel-plugin-syntax-hermes-parser",children:"babel-plugin-syntax-hermes-parser"})," plugin version 0.26+, see our ",(0,o.jsx)(s.a,{href:"../../tools/babel",children:"Babel guide"})," for more details."]}),"\n",(0,o.jsxs)(s.li,{children:["ESLint: use ",(0,o.jsx)(s.a,{href:"https://www.npmjs.com/package/hermes-eslint",children:"hermes-eslint"})," plugin version 0.26+, see our ",(0,o.jsx)(s.a,{href:"../../tools/eslint",children:"ESLint guide"})," for more details."]}),"\n"]})]})}function p(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>c});var t=n(96540);const o={},i=t.createContext(o);function r(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);