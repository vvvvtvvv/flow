"use strict";(self.webpackChunknew_website=self.webpackChunknew_website||[]).push([[3559],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var o=t(96540);const c={},r=o.createContext(c);function s(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:s(e.components),o.createElement(r.Provider,{value:n},e.children)}},43559:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"react/types","title":"Type Reference","description":"React exports a handful of utility types that may be useful to you when typing","source":"@site/docs/react/types.md","sourceDirName":"react","slug":"/react/types","permalink":"/en/docs/react/types","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/flow/edit/main/website/docs/react/types.md","tags":[],"version":"current","frontMatter":{"title":"Type Reference","slug":"/react/types"},"sidebar":"docsSidebar","previous":{"title":"Render Types","permalink":"/en/docs/react/render-types"},"next":{"title":"Flow Enums","permalink":"/en/docs/enums"}}');var c=t(74848),r=t(28453);const s={title:"Type Reference",slug:"/react/types"},a=void 0,i={},l=[{value:"<code>React.Node</code>",id:"toc-react-node",level:2},{value:"<code>React.MixedElement</code>",id:"toc-react-mixedelement",level:2},{value:"<code>React.ChildrenArray&lt;T&gt;</code>",id:"toc-react-childrenarray",level:2},{value:"<code>React.AbstractComponent&lt;Config, Instance, Renders&gt;</code>",id:"toc-react-abstractcomponent",level:2},{value:"<code>React.ComponentType&lt;Config&gt;</code>",id:"toc-react-componenttype",level:2},{value:"<code>React.ElementType</code>",id:"toc-react-elementtype",level:2},{value:"<code>React.Key</code>",id:"toc-react-key",level:2},{value:"<code>React.Ref&lt;typeof Component&gt;</code>",id:"toc-react-ref",level:2},{value:"<code>React.PropsOf&lt;Component&gt;</code>",id:"toc-react-propsof",level:2},{value:"<code>React.ElementConfig&lt;typeof Component&gt;</code>",id:"toc-react-elementconfig",level:2},{value:"<code>React.ElementProps&lt;typeof Component&gt;</code>",id:"toc-react-elementprops",level:2},{value:"<code>React.RefOf&lt;Component&gt;</code>",id:"toc-react-refof",level:2},{value:"<code>React.ElementRef&lt;typeof Component&gt;</code>",id:"toc-react-elementref",level:2},{value:"<code>React.Config&lt;Props, DefaultProps&gt;</code>",id:"toc-react-config",level:2},{value:"<code>ExactReactElement_DEPRECATED&lt;typeof Component&gt;</code>",id:"toc-react-element",level:2}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.p,{children:"React exports a handful of utility types that may be useful to you when typing\nadvanced React patterns. In previous sections we have seen a few of them. The\nfollowing is a complete reference for each of these types along with some\nexamples for how/where to use them."}),"\n",(0,c.jsxs)(n.p,{children:["These types are all exported as named type exports from the ",(0,c.jsx)(n.code,{children:"react"})," module. If\nyou want to access them as members on the ",(0,c.jsx)(n.code,{children:"React"})," object (e.g.\n",(0,c.jsx)(n.a,{href:"#toc-react-node",children:(0,c.jsx)(n.code,{children:"React.Node"})}),") and\nyou are importing React as an ES module then you should import ",(0,c.jsx)(n.code,{children:"React"})," as a\nnamespace:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"import * as React from 'react';\n"})}),"\n",(0,c.jsx)(n.p,{children:"If you are using CommonJS you can also require React:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const React = require('react');\n"})}),"\n",(0,c.jsx)(n.p,{children:"You can also use named type imports in either an ES module environment or a\nCommonJS environment:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"import type {Node} from 'react';\n"})}),"\n",(0,c.jsx)(n.p,{children:"We will refer to all the types in the following reference as if we imported them\nwith:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"import * as React from 'react';\n"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"Note:"})," While importing React with a default import works:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"import React from 'react';\n"})}),"\n",(0,c.jsxs)(n.p,{children:["You will have access to all of the values that React exports, but you will\n",(0,c.jsx)(n.strong,{children:"not"})," have access to the types documented below! This is because Flow will\nnot add types to a default export since the default export could be any value\n(like a number). Flow will add exported named types to an ES namespace object\nwhich you can get with ",(0,c.jsx)(n.code,{children:"import * as React from 'react'"})," since Flow knows if\nyou export a value with the same name as an exported type."]}),"\n",(0,c.jsxs)(n.p,{children:["Again, if you import React with: ",(0,c.jsx)(n.code,{children:"import React from 'react'"})," you will be able\nto access ",(0,c.jsx)(n.code,{children:"React.Component"}),", ",(0,c.jsx)(n.code,{children:"React.createElement()"}),", ",(0,c.jsx)(n.code,{children:"React.Children"}),", and\nother JavaScript ",(0,c.jsx)(n.em,{children:"values"}),". However, you will not be able to access\n",(0,c.jsx)(n.a,{href:"#toc-react-node",children:(0,c.jsx)(n.code,{children:"React.Node"})}),", ",(0,c.jsx)(n.a,{href:"#toc-react-childrenarray",children:(0,c.jsx)(n.code,{children:"React.ChildrenArray"})})," or\nother Flow ",(0,c.jsx)(n.em,{children:"types"}),". You will need to use a named type import like:\n",(0,c.jsx)(n.code,{children:"import type {Node} from 'react'"})," in addition to your default import."]}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"toc-react-node",children:(0,c.jsx)(n.code,{children:"React.Node"})}),"\n",(0,c.jsxs)(n.p,{children:["This represents any node that can be rendered in a React application.\n",(0,c.jsx)(n.code,{children:"React.Node"})," can be null, a boolean, a number, a string, a React\nelement, or an array of any of those types recursively."]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"React.Node"})," is a good default to use to annotate the return type of a function component\nand class render methods. You can also use it to type elements your component takes in as children."]}),"\n",(0,c.jsxs)(n.p,{children:["Here is an example of ",(0,c.jsx)(n.code,{children:"React.Node"})," being used as the return type to a function component:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function MyComponent(props: {}): React.Node {\n  // ...\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["It may also be used as the return type of a class ",(0,c.jsx)(n.code,{children:"render"})," method:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"class MyComponent extends React.Component<{}> {\n  render(): React.Node {\n    // ...\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["Here is an example of ",(0,c.jsx)(n.code,{children:"React.Node"})," as the prop type for children:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function MyComponent({ children }: { children: React.Node }) {\n  return <div>{children}</div>;\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["All ",(0,c.jsx)(n.code,{children:"react-dom"})," JSX intrinsics have ",(0,c.jsx)(n.code,{children:"React.Node"})," as their children type.\n",(0,c.jsx)(n.code,{children:"<div>"}),", ",(0,c.jsx)(n.code,{children:"<span>"}),", and all the rest."]}),"\n",(0,c.jsx)(n.h2,{id:"toc-react-mixedelement",children:(0,c.jsx)(n.code,{children:"React.MixedElement"})}),"\n",(0,c.jsxs)(n.p,{children:["The most general type of all React elements (similar to ",(0,c.jsx)(n.code,{children:"mixed"})," for all values)."]}),"\n",(0,c.jsx)(n.p,{children:"A common use case of this type is when we want to annotate an element with a type that hides the element details. For example"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const element: React.MixedElement = <div />;\n"})}),"\n",(0,c.jsx)(n.h2,{id:"toc-react-childrenarray",children:(0,c.jsx)(n.code,{children:"React.ChildrenArray<T>"})}),"\n",(0,c.jsxs)(n.p,{children:["A React children array can be a single value or an array nested to any level.\nIt is designed to be used with the ",(0,c.jsxs)(n.a,{href:"https://react.dev/reference/react/Children",children:[(0,c.jsx)(n.code,{children:"React.Children"})," API"]}),"."]}),"\n",(0,c.jsxs)(n.p,{children:["For example if you want to get a normal JavaScript array from a\n",(0,c.jsx)(n.code,{children:"React.ChildrenArray<T>"})," see the following example:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"import * as React from 'react';\n\n// A children array can be a single value...\nconst children: React.ChildrenArray<number> = 42;\n// ...or an arbitrarily nested array.\nconst children: React.ChildrenArray<number> = [[1, 2], 3, [4, 5]];\n\n// Using the `React.Children` API can flatten the array.\nconst array: Array<number> = React.Children.toArray(children);\n"})}),"\n",(0,c.jsx)(n.h2,{id:"toc-react-abstractcomponent",children:(0,c.jsx)(n.code,{children:"React.AbstractComponent<Config, Instance, Renders>"})}),"\n",(0,c.jsx)(n.admonition,{type:"tip",children:(0,c.jsxs)(n.p,{children:["In Flow v0.243.0+, consider using ",(0,c.jsx)(n.a,{href:"../component-types",children:"Component Types"})," instead, which will make\nit easier to migrate your Flow code to React 19. The type will be removed in Flow v0.251.0."]})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"React.AbstractComponent<Config, Instance, Renders>"})," represents a component with\na config of type Config and instance of type Instance that renders something of type Renders."]}),"\n",(0,c.jsxs)(n.p,{children:["The ",(0,c.jsx)(n.code,{children:"Config"})," of a component is the type of the object you need to pass in to JSX in order\nto create an element with that component. The ",(0,c.jsx)(n.code,{children:"Instance"})," of a component is the type of the value\nthat is written to the ",(0,c.jsx)(n.code,{children:"current"})," field of a ref object passed into the ",(0,c.jsx)(n.code,{children:"ref"})," prop in JSX.\n",(0,c.jsx)(n.code,{children:"Renders"})," is a ",(0,c.jsx)(n.a,{href:"../component-syntax",children:"Component Syntax"})," feature that allows you to specify what your\ncomponent renders via ",(0,c.jsx)(n.a,{href:"../render-types",children:"Render Types"})]}),"\n",(0,c.jsx)(n.p,{children:"Config is required, but Instance is optional and defaults to mixed and Renders is optional and defaults to React.Node."}),"\n",(0,c.jsxs)(n.p,{children:["A class or function component with config ",(0,c.jsx)(n.code,{children:"Config"})," may be used in places that expect\n",(0,c.jsx)(n.code,{children:"React.AbstractComponent<Config>"}),"."]}),"\n",(0,c.jsx)(n.p,{children:"This is Flow's most abstract representation of a React component, and is most useful for\nwriting HOCs and library definitions."}),"\n",(0,c.jsx)(n.h2,{id:"toc-react-componenttype",children:(0,c.jsx)(n.code,{children:"React.ComponentType<Config>"})}),"\n",(0,c.jsxs)(n.p,{children:["This is the same as ",(0,c.jsx)(n.a,{href:"#toc-react-abstractcomponent",children:(0,c.jsx)(n.code,{children:"React.AbstractComponent"})}),", but only specifies the first type argument."]}),"\n",(0,c.jsx)(n.h2,{id:"toc-react-elementtype",children:(0,c.jsx)(n.code,{children:"React.ElementType"})}),"\n",(0,c.jsxs)(n.p,{children:["Similar to ",(0,c.jsx)(n.a,{href:"#toc-react-abstractcomponent",children:(0,c.jsx)(n.code,{children:"React.AbstractComponent<Props>"})})," except it also\nincludes JSX intrinsics (strings)."]}),"\n",(0,c.jsxs)(n.p,{children:["The definition for ",(0,c.jsx)(n.code,{children:"React.ElementType"})," is roughly:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"type ElementType =\n  | string\n  | React.ComponentType<empty>;\n"})}),"\n",(0,c.jsx)(n.h2,{id:"toc-react-key",children:(0,c.jsx)(n.code,{children:"React.Key"})}),"\n",(0,c.jsx)(n.p,{children:"The type of the key prop on React elements. It is a union of strings and\nnumbers defined as:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"type Key = string | number;\n"})}),"\n",(0,c.jsx)(n.h2,{id:"toc-react-ref",children:(0,c.jsx)(n.code,{children:"React.Ref<typeof Component>"})}),"\n",(0,c.jsxs)(n.p,{children:["The type of the ",(0,c.jsx)(n.a,{href:"https://react.dev/learn/manipulating-the-dom-with-refs",children:"ref prop on React elements"}),". ",(0,c.jsx)(n.code,{children:"React.Ref<typeof Component>"}),"\ncould be a string, ref object, or ref function."]}),"\n",(0,c.jsxs)(n.p,{children:["The ref function will take one and only argument which will be the element\ninstance which is retrieved using\n",(0,c.jsx)(n.a,{href:"#toc-react-elementref",children:(0,c.jsx)(n.code,{children:"React.ElementRef<typeof Component>"})})," or null since\n",(0,c.jsx)(n.a,{href:"https://react.dev/learn/manipulating-the-dom-with-refs#how-to-manage-a-list-of-refs-using-a-ref-callback",children:"React will pass null into a ref function when unmounting"}),"."]}),"\n",(0,c.jsxs)(n.p,{children:["Like ",(0,c.jsx)(n.a,{href:"#toc-react-element",children:(0,c.jsx)(n.code,{children:"React.Element<typeof Component>"})}),", ",(0,c.jsx)(n.code,{children:"typeof Component"}),"\nmust be the type ",(0,c.jsx)(n.em,{children:"of"})," a React component so you need to use ",(0,c.jsx)(n.code,{children:"typeof"})," as in\n",(0,c.jsx)(n.code,{children:"React.Ref<typeof MyComponent>"}),"."]}),"\n",(0,c.jsxs)(n.p,{children:["The definition for ",(0,c.jsx)(n.code,{children:"React.Ref<typeof Component>"})," is roughly:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"type Ref<C> =\n  | string\n  | (instance: React.ElementRef<C> | null) => mixed;\n  | { -current: React$ElementRef<ElementType> | null, ... }\n"})}),"\n",(0,c.jsx)(n.h2,{id:"toc-react-propsof",children:(0,c.jsx)(n.code,{children:"React.PropsOf<Component>"})}),"\n",(0,c.jsxs)(n.p,{children:["When ",(0,c.jsx)(n.code,{children:"Component"})," is written using ",(0,c.jsx)(n.a,{href:"../component-syntax",children:"Component Syntax"}),", ",(0,c.jsx)(n.code,{children:"React.PropsOf<Component>"}),"\ngives you the type of an object that you must pass in to instantiate ",(0,c.jsx)(n.code,{children:"Component"})," with JSX.\nImportantly, the props with defaults are optional in the resulting type."]}),"\n",(0,c.jsx)(n.p,{children:"For example:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-flow",metastring:"[]",children:"import * as React from 'react';\n\ncomponent MyComponent(foo: number, bar: string = 'str') {\n  return null;\n}\n\n// Only foo is required\n({foo: 3}) as React.PropsOf<MyComponent>;\n"})}),"\n",(0,c.jsx)(n.h2,{id:"toc-react-elementconfig",children:(0,c.jsx)(n.code,{children:"React.ElementConfig<typeof Component>"})}),"\n",(0,c.jsxs)(n.p,{children:["Like ",(0,c.jsx)(n.a,{href:"#toc-react-propsof",children:"React.PropsOf"}),", this utility gets the type of the object that you must pass in to a\ncomponent in order to instantiate it via ",(0,c.jsx)(n.code,{children:"createElement()"})," or ",(0,c.jsx)(n.code,{children:"jsx()"}),". While ",(0,c.jsx)(n.code,{children:"PropsOf"})," takes in an element of\na component, which is convenient when using ",(0,c.jsx)(n.a,{href:"../component-syntax",children:"Component Syntax"}),", ",(0,c.jsx)(n.code,{children:"ElementConfig"})," takes in the type of a component\ninstead. ",(0,c.jsx)(n.code,{children:"typeof Component"})," must be the type ",(0,c.jsx)(n.em,{children:"of"})," a React component so you need to use ",(0,c.jsx)(n.code,{children:"typeof"})," as in\n",(0,c.jsx)(n.code,{children:"React.ElementConfig<typoef Component>"}),"."]}),"\n",(0,c.jsx)(n.p,{children:"Importantly, props with defaults are optional in the resulting type."}),"\n",(0,c.jsx)(n.p,{children:"For example,"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"import * as React from 'react';\n\nclass MyComponent extends React.Component<{foo: number}> {\n  static defaultProps = {foo: 42};\n\n  render() {\n    return this.props.foo;\n  }\n}\n\n// `React.ElementProps<>` requires `foo` even though it has a `defaultProp`.\n({foo: 42}) as React.ElementProps<typeof MyComponent>;\n\n// `React.ElementConfig<>` does not require `foo` since it has a `defaultProp`.\n({}) as React.ElementConfig<typeof MyComponent>;\n"})}),"\n",(0,c.jsxs)(n.p,{children:["Like ",(0,c.jsx)(n.a,{href:"#toc-react-element",children:(0,c.jsx)(n.code,{children:"React.Element<typeof Component>"})}),", ",(0,c.jsx)(n.code,{children:"typeof Component"})," must be the\ntype ",(0,c.jsx)(n.em,{children:"of"})," a React component so you need to use ",(0,c.jsx)(n.code,{children:"typeof"})," as in\n",(0,c.jsx)(n.code,{children:"React.ElementProps<typeof MyComponent>"}),"."]}),"\n",(0,c.jsx)(n.h2,{id:"toc-react-elementprops",children:(0,c.jsx)(n.code,{children:"React.ElementProps<typeof Component>"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"Note:"})," Because ",(0,c.jsx)(n.a,{href:"#toc-react-elementprops",children:(0,c.jsx)(n.code,{children:"React.ElementProps"})})," does not preserve the optionality of ",(0,c.jsx)(n.code,{children:"defaultProps"}),", ",(0,c.jsx)(n.a,{href:"#toc-react-elementconfig",children:(0,c.jsx)(n.code,{children:"React.ElementConfig"})})," (which does) is more often the right choice, especially for simple props pass-through as with ",(0,c.jsx)(n.a,{href:"../hoc/#toc-supporting-defaultprops-with-react-elementconfig",children:"higher-order components"}),".\nYou probably should not use ElementProps."]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["Gets the props for a React element type, ",(0,c.jsx)(n.em,{children:"without"})," preserving the optionality of ",(0,c.jsx)(n.code,{children:"defaultProps"}),".\n",(0,c.jsx)(n.code,{children:"typeof Component"})," could be the type of a React class component, a function component, or a JSX intrinsic string.\nThis type is used for the ",(0,c.jsx)(n.code,{children:"props"})," property on ",(0,c.jsx)(n.a,{href:"#toc-react-element",children:(0,c.jsx)(n.code,{children:"React.Element<typeof Component>"})}),"."]}),"\n",(0,c.jsxs)(n.p,{children:["Like ",(0,c.jsx)(n.a,{href:"#toc-react-element",children:(0,c.jsx)(n.code,{children:"React.Element<typeof Component>"})}),", ",(0,c.jsx)(n.code,{children:"typeof Component"})," must be the\ntype ",(0,c.jsx)(n.em,{children:"of"})," a React component so you need to use ",(0,c.jsx)(n.code,{children:"typeof"})," as in\n",(0,c.jsx)(n.code,{children:"React.ElementProps<typeof MyComponent>"}),"."]}),"\n",(0,c.jsx)(n.h2,{id:"toc-react-refof",children:(0,c.jsx)(n.code,{children:"React.RefOf<Component>"})}),"\n",(0,c.jsxs)(n.p,{children:["When using ",(0,c.jsx)(n.a,{href:"../component-syntax",children:"Component Syntax"}),", ",(0,c.jsx)(n.code,{children:"React.RefOf<Component>"})," will give you\nthe type of the ",(0,c.jsx)(n.code,{children:"current"})," field on the ",(0,c.jsx)(n.code,{children:"ref"})," prop of the component. If there is no ",(0,c.jsx)(n.code,{children:"ref"})," prop\non the component it will return ",(0,c.jsx)(n.code,{children:"void"}),"."]}),"\n",(0,c.jsx)(n.h2,{id:"toc-react-elementref",children:(0,c.jsx)(n.code,{children:"React.ElementRef<typeof Component>"})}),"\n",(0,c.jsx)(n.p,{children:"Gets the instance type for a React element. The instance will be different for\nvarious component types:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"component(ref: React.RefSetter<Instance>)"})," will return the ",(0,c.jsx)(n.code,{children:"Instance"})," type."]}),"\n",(0,c.jsxs)(n.li,{children:["React class components will be the class instance. So if you had\n",(0,c.jsx)(n.code,{children:"class Foo extends React.Component<{}> {}"})," and used\n",(0,c.jsx)(n.code,{children:"React.ElementRef<typeof Foo>"})," then the type would be the instance of ",(0,c.jsx)(n.code,{children:"Foo"}),"."]}),"\n",(0,c.jsxs)(n.li,{children:["React function components do not have a backing instance and so\n",(0,c.jsx)(n.code,{children:"React.ElementRef<typeof Bar>"})," (when ",(0,c.jsx)(n.code,{children:"Bar"})," is ",(0,c.jsx)(n.code,{children:"function Bar() {}"}),") will give\nyou the void type."]}),"\n",(0,c.jsxs)(n.li,{children:["JSX intrinsics like ",(0,c.jsx)(n.code,{children:"div"})," will give you their DOM instance. For\n",(0,c.jsx)(n.code,{children:"React.ElementRef<'div'>"})," that would be ",(0,c.jsx)(n.code,{children:"HTMLDivElement"}),". For\n",(0,c.jsx)(n.code,{children:"React.ElementRef<'input'>"})," that would be ",(0,c.jsx)(n.code,{children:"HTMLInputElement"}),"."]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["Like ",(0,c.jsx)(n.a,{href:"#toc-react-element",children:(0,c.jsx)(n.code,{children:"React.Element<typeof Component>"})}),", ",(0,c.jsx)(n.code,{children:"typeof Component"})," must be the\ntype ",(0,c.jsx)(n.em,{children:"of"})," a React component so you need to use ",(0,c.jsx)(n.code,{children:"typeof"})," as in\n",(0,c.jsx)(n.code,{children:"React.ElementRef<typeof MyComponent>"}),"."]}),"\n",(0,c.jsx)(n.h2,{id:"toc-react-config",children:(0,c.jsx)(n.code,{children:"React.Config<Props, DefaultProps>"})}),"\n",(0,c.jsxs)(n.admonition,{type:"warning",children:[(0,c.jsx)(n.p,{children:"This type will be removed in 0.257.0. This type is usually only useful for legacy class components.\nYou can create your own equivalent type with"}),(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-flow",children:"type ReactConfigShim<Props, DefaultProps> = $ReadOnly<{\n  ...Omit<Props, $Keys<DefaultProps>>, ...Partial<DefaultProps>\n}>;\n"})})]}),"\n",(0,c.jsx)(n.p,{children:"Calculates a config object from props and default props."}),"\n",(0,c.jsx)(n.h2,{id:"toc-react-element",children:(0,c.jsx)(n.code,{children:"ExactReactElement_DEPRECATED<typeof Component>"})}),"\n",(0,c.jsx)(n.admonition,{type:"warning",children:(0,c.jsxs)(n.p,{children:["This is an exact replacement of the removed 'React.Element' type since 0.245.\nYou should use ",(0,c.jsx)(n.code,{children:"React.MixedElement"})," or ",(0,c.jsx)(n.code,{children:"React.Node"})," instead.\nIf you want to enforce design system constraints, use ",(0,c.jsx)(n.a,{href:"../render-types",children:"render types"})," instead."]})}),"\n",(0,c.jsx)(n.p,{children:"A React element is the type for the value of a JSX element:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const element: ExactReactElement_DEPRECATED<'div'> = <div />;\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"ExactReactElement_DEPRECATED<typeof Component>"})," is also the return type of\n",(0,c.jsx)(n.code,{children:"React.createElement()"}),"/",(0,c.jsx)(n.code,{children:"React.jsx()"}),"."]}),"\n",(0,c.jsxs)(n.p,{children:["A ",(0,c.jsx)(n.code,{children:"ExactReactElement_DEPRECATED"})," takes a single type argument,\n",(0,c.jsx)(n.code,{children:"typeof Component"}),". ",(0,c.jsx)(n.code,{children:"typeof Component"})," is the component type of the React\nelement. For an intrinsic element, ",(0,c.jsx)(n.code,{children:"typeof Component"})," will be the string literal\nfor the intrinsic you used. Here are a few examples with DOM intrinsics:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"<div /> as ExactReactElement_DEPRECATED<'div'>; // OK\n<span /> as ExactReactElement_DEPRECATED<'span'>; // OK\n<div /> as ExactReactElement_DEPRECATED<'span'>; // Error: div is not a span.\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"typeof Component"})," can also be your React class component or function component."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function Foo(props: {}) {}\nclass Bar extends React.Component<{}> {}\n\n<Foo /> as ExactReactElement_DEPRECATED<typeof Foo>; // OK\n<Bar /> as ExactReactElement_DEPRECATED<typeof Bar>; // OK\n<Foo /> as ExactReactElement_DEPRECATED<typeof Bar>; // Error: Foo is not Bar\n"})}),"\n",(0,c.jsxs)(n.p,{children:["Take note of the ",(0,c.jsx)(n.code,{children:"typeof"}),", it is required! We want to get the\ntype ",(0,c.jsx)(n.em,{children:"of"})," the value ",(0,c.jsx)(n.code,{children:"Foo"}),". ",(0,c.jsx)(n.code,{children:"Foo as Foo"})," is an error because ",(0,c.jsx)(n.code,{children:"Foo"})," cannot be used\nas a type, so the following is correct: ",(0,c.jsx)(n.code,{children:"Foo as typeof Foo"}),"."]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Bar"})," without ",(0,c.jsx)(n.code,{children:"typeof"})," would be the type of an instance of ",(0,c.jsx)(n.code,{children:"Bar"}),": ",(0,c.jsx)(n.code,{children:"new Bar() as Bar"}),".\nWe want the type ",(0,c.jsx)(n.em,{children:"of"})," ",(0,c.jsx)(n.code,{children:"Bar"})," not the type of an instance of ",(0,c.jsx)(n.code,{children:"Bar"}),".\n",(0,c.jsx)(n.code,{children:"Class<Bar>"})," would also work here, but we prefer ",(0,c.jsx)(n.code,{children:"typeof"})," for consistency\nwith function components."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}}}]);